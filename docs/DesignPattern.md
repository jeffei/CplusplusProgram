# 设计模式
## 封装变化,多用组合,少用继承 针对接口编程,不针对实现编程，为交互对象之间的松耦合设计而努力
## 六大原则：
*1 单一职责 ：
** 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。
** 一个类只负责一项职责
*2 里氏替换 ：
** 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。
** 子类可以扩展父类的功能，但不能改变父类原有的功能
*3 依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
** 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
** 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程
*4 接口隔离：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
** 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
** 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。
*5 迪米特法则：一个对象应该对其他对象保持最少的了解。
** 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。
** 降低类之间的耦合
*6 开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
** 问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
** 用抽象构建框架，用实现扩展细节
## 简单工厂、工厂方法、抽象工厂、策略模式的区别：
*
*
